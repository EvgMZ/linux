# Report

## Part 1. Инструмент ipcalc

- `ipcalc` - это утилита командной строки в Linux, которая используется для вычисления сетевых масок, подсетей, широковещательных адресов и других сетевых характеристик на основе заданного IP-адреса и маски.

### 1.1. Сети и маски

#### 1) Адрес сети 192.167.38.54/13

<div align= "center">

![](./images/part1_1.jpg)
<br>
<i>`ipclac 192.167.38.54/13`</i>

</div>

- адрес сети 192.167.38.54 -192.167.0.0

#### 2) Перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную.

<div align= "center">

![](./images/part1_2_1.jpg)
<br>
<i>`ipclac 255.255.255.0`</i>

</div>

- префиксная - `11111111.11111111.11111111.00000000`
  <br>

- обычная - `/24`
  <br>
  <br>

<div align= "center">

![](./images/part1_2_2.jpg)
<br>
<i>`ipclac /15`</i>

</div>

- обычная - `255.254.0.0.`
  <br>

- двоичная - `11111111.11111110.00000000.00000000`
  <br>
  <br>

<div align= "center">

![](./images/part1_2_3.jpg)
<br>
<i>`ipclac 11111111.11111111.11111111.11110000`</i>

</div>

- обычная - `255.255.255.240`
  <br>

- префиксная - `/28`
  <br>
  <br>

#### 3) минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4

<div align= "center">

![](./images/part1_3_1.jpg)
<br>
<i>`ipclac 12.167.38.4/8,/16,/23`</i>

</div>

- При маске /8(255.0.0.0), адрес сети будет 12.0.0.0, а максимальный адрес хоста - 12.255.255.254. Минимальный адрес хоста - 12.0.0.1.

- При маске 11111111.11111111.00000000.00000000 (255.255.0.0), адрес сети будет также 12.167.0.0, максимальный адрес хоста - 12.167.255.254, а минимальный адрес хоста - 12.167.0.1.

- При маске 255.255.254.0 (/23), адрес сети будет 12.167.38.0, максимальный адрес хоста - 12.167.39.254, а минимальный адрес хоста - 12.167.38.1.
  <br>
  <br>

<div align= "center">

![](./images/part1_3_2.jpg)
<br>
<i>`ipclac 12.167.38.4/4`</i>

</div>

- При маске /4 (240.0.0.0), адрес сети будет 0.0.0.0/4, максимальный адрес хоста - 15.255.255.254, а минимальный адрес хоста - 0.0.0.1.

## 1.2. localhost

#### 1) Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1

- можно обратиться
  - 127.0.0.1
  - 127.0.0.2
- нельзя обратиться
  - 194.34.23.100
  - 127.1.0.1

## 1.3. Диапазоны и сегменты сетей

#### 1) Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1

- Частный и публичный IP-адреса можно определить по их диапазону.

- В IPv4 есть три диапазона частных IP-адресов:
  - 10.0.0.0 - 10.255.255.255 (диапазон /8)
  - 172.16.0.0 - 172.31.255.255 (диапазон /12)
  - 192.168.0.0 - 192.168.255.255 (диапазон /16)
- Все остальные IP-адреса считаются публичными.

- приватные адресса

  - 10.0.0.45
  - 192.168.4.2
  - 172.20.250.4
  - 172.16.255.255
  - 10.10.10.10

- публичные адресса

  - 134.43.0.2
  - 172.0.2.1
  - 192.172.0.1
  - 172.68.0.2
  - 192.169.168.1

#### 2) Какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

- диапозон адресов возможны для данной сети - 10.10.0.1 - 10.10.63.254

<div align= "center">

![](./images/part1_4_1.jpg)
<br>
<i>`ipclac 10.10.0.0/18`</i>

</div>

- поэтому для сети 10.10.0.0 возможны адреса
  - 10.10.0.2
  - 10.10.10.10
  - 10.10.1.255

## Part 2. Статическая маршрутизация между двумя машинами

#### 2.0.1 Поднять две виртуальные машины (далее -- ws1 и ws2)

<div align= "center">

![](./images/part2_0_1.jpg)
<br>
<i>`ipclac 10.10.0.0/18`</i>

</div>

#### 2.0.2 С помощью команды ip a посмотреть существующие сетевые интерфейс

<div align= "center">

![](./images/part2_0_2.jpg)
<br>
<i>ws1:`ip a`</i>
<br>
<br>
![](./images/part2_0_2.jpg)
<br>
<i>ws2:`ip a`</i>

</div>

#### 2.0.3 Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12

Сетевой интерфейс, соответствующий внутренней сети, это интерфейс, который подключен к локальной сети внутри организации или домашней сети и предназначен для обмена данными между устройствами в этой сети. Обычно такие интерфейсы имеют адреса из частных IP-диапазонов, например, 192.168.x.x, 172.16.x.x - 172.31.x.x или 10.x.x.x.

В сетевых настройках такой интерфейс может быть настроен для использования DHCP, если адреса присваиваются автоматически, или для использования статических IP-адресов, если адреса присваиваются вручную. Также могут быть настроены другие параметры, такие как маска подсети, шлюз по умолчанию и DNS-серверы.

Кроме того, внутренний интерфейс может иметь дополнительные параметры безопасности, такие как настройки брандмауэра, чтобы защитить локальную сеть от внешних угроз.

- Для открытия файлы конфигурации сетевых интерфейсов используем команду:

> `sudo vi /etc/netplan/00-installer-config.yaml

- 00-installer-config.yaml - файл конфигурации сетевых интерфейсов

<div align= "center">

![](./images/part2_0_3_1.jpg)
<br>
<i>ws1</i>
<br>
![](./images/part2_0_3_2.jpg)
<br>
<i>ws2</i>
<br>

</div>

#### 2.0.4 Выполнить команду netplan apply для перезапуска сервиса сети

- Прописываем комманды для принятие новых настроек конфигурации сети и перезапуска сервиса:

> `sudo netplan apply`

<div align= "center">

![](./images/part2_0_4_1.jpg)
<br>
![](./images/part2_0_4_2.jpg)
<br>

</div>

- Проверяем настройки с помощью команды:

  > `ip a`

<div align= "center">

![](./images/part2_0_4_3.jpg)
<br>
<i>ws1</i>
<br>
![](./images/part2_0_4_4.jpg)
<br>
<i>ws2</i>
<br>

</div>

### 2.1. Добавление статического маршрута вручную

#### 2.1.1 Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add

статистически задаем маршрут с помощью команды:

> `sudo ip r add <target_network> dev <device>`

<div align= "center">

![](./images/part2_1_1.jpg)
<br>
<i>`sudo ip r add 172.24.116.8 dev enp0s1`</i>
<br>
<br>
![](./images/part2_1_2.jpg)
<br>
<i>`sudo ip r add 192.168.100.0 dev enp0s1`</i>
<br>

</div>

#### 2.1.2 Пропинговать соединение между машинами

пропингуем соединения с помощью команды:

> `ping -w 3 <target_network>`

<div align= "center">

![](./images/part2_1_3.jpg)
<br>
<i>`ping -w 3 172.24.116.8`</i>
<br>
<br>
![](./images/part2_1_4.jpg)
<br>
<i>`ping -w 3 192.168.100.0`</i>
<br>

</div>

### 2.2. Добавление статического маршрута с сохранением

#### Перезапустить машины

После перезапуска машины заданные статистические маршруты удалились

<div align= "center">

![](./images/part2_2_1.jpg)
<br>
<i>`ws1`</i>
<br>
<br>
![](./images/part2_2_2.jpg)
<br>
<i>`ws2`</i>
<br>

</div>

#### Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml

Для добавления статического маршрута не проподающего после перезагрузки, добавляем в yaml файл следующие строки:

> `sudo vi /etc/netplan/00-installer-config.yaml`

<div align= "center">

![](./images/part2_2_3.jpg)
<br>
<i>`ws1`</i>
<br>
<br>
![](./images/part2_2_4.jpg)
<br>
<i>`ws2`</i>
<br>

</div>

Применяем новую конфигурацию файла:

> `sudo netplan apply`

#### Пропинговать соединение между машинами

Пропингуем соеденения на двух машинах:

<div align= "center">

![](./images/part2_2_5.jpg)
<br>
<i>`ping -w 3 172.24.116.8`</i>
<br>
<br>
![](./images/part2_2_6.jpg)
<br>
<i>`ping -w 3 192.168.100.0`</i>
<br>

</div>

## Part 3. Утилита iperf3

### 3.1. Скорость соединения

#### Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps

- 8 Mbps == 1 MB/s
- 100 MB/s == 800000 Kbps
- 1 Gbps == 1000 Mbps

### 3.2. Утилита iperf3

> `Iperf3` - это утилита командной строки для измерения пропускной способности сети TCP и UDP. Она используется для проверки скорости передачи данных между двумя узлами в сети. Одна узел работает в качестве сервера, а другой - в качестве клиента. Клиент отправляет данные на сервер, и утилита измеряет скорость передачи данных, задержку и другие параметры.

Чтобы создать сервер испольузется команда:

> `iperf3 -s [option]`

> `-f` - используется для указания формата отображения результатов измерения скорости сетевого соединения (k - кбит, m - мегабит, g - гигабит или K - килобайт, M - мегабайт, G - гигабайт)

> `-D` - запускает сервер в фоновом режиме, что означает, что сервер будет запущен как демон и не будет выводить результаты тестирования на консоль. Это может быть полезно для длительных тестов или в случае, когда требуется тестировать сеть с использованием многих клиентов.

Чтобы запустить **iperf3** в клиентском режиме используем флаг **-с** и указываем адрес хоста, на котором работает сервер.

> `iperf3 -c [host_address] [oprion]`

#### Измерить скорость соединения между ws1 и ws2

Чтобы измерить скорость передачи данных между двумя ВМ создадим на ws1 сервер, а на ws2 клиента.

Создадим сервер на ws1 командой:

> `iperf3 -s`

Создадим клиента на ws2, делающего запрос на созданный ранее сервер:

> `iperf3 -c 192.168.100.10`

<div align= "center">

![](./images/part3_1.jpg)
<br>
<i>ws1</i>
<br>
<br>
![](./images/part3_2.jpg)
<br>
<i>ws2</i>
<br>

</div>

Скорость соединения:

- sender: 2.10 Gbits/sec
- receiver: 2.10 Gbits/sec

## Part 4. Сетевой экран

Сетевой экран (firewall) - это программное или аппаратное устройство, которое используется для фильтрации трафика в сети, обеспечения безопасности и защиты от вредоносных атак

### 4.1. Утилита iptables

> `iptables` - это утилита командной строки для настройки правил фильтрации сетевого трафика в Linux. Она позволяет создавать правила для блокировки или разрешения доступа к определенным портам, протоколам и IP-адресам.

С помощью iptables можно настроить межсетевой экран (firewall), который будет обеспечивать безопасность сетевого трафика, пропуская только тот трафик, который соответствует заранее заданным правилам.

Общий синтаксис команды iptables выглядит так:

> `$ iptables [option] [chain] [rule]`

- A - добавить правило в цепочку;
- С - проверить все правила;
- D - удалить правило;
- I - вставить правило с нужным номером;
- L - вывести все правила в текущей цепочке;
- S - вывести все правила;
- F - очистить все правила;
- N - создать цепочку;
- X - удалить цепочку;
- P - установить действие по умолчанию.

Дополнительные опции для правил:

- p - указать протокол, один из tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp,
  m h;
- s - указать ip адрес устройства-отправителя пакета;
- d - указать ip адрес получателя;
- i - входной сетевой интерфейс;
- o - исходящий сетевой интерфейс;
- j - выбрать действие, если правило подошло.

##### Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:

Переходим в корневую папку и создаем файл firewall.sh на ws1 и ws2:

> `sudo touch /etc/firewall.sh`

Чтобы добавить новые правила испльзуем команду:

> `sudo vi /etc/firewall.sh`

#### Нужно добавить в файл подряд следующие правила:

1. На ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило

2. на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)

3. открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)

4. запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)

5. разрешить echo reply (машина должна "пинговаться")

<div align= "center">

![](./images/part4_1.jpg)
<br>
<i>ws1</i>
<br>
<br>
![](./images/part4_2.jpg)
<br>
<i>ws2</i>
<br>

</div>

#### Запустить файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh

Также пременим команду для просмотра применных правил:

> `sudo iptables -L -nv`

<div align= "center">

![](./images/part4_3.jpg)
<br>
<i>ws1</i>
<br>
<br>
![](./images/part4_4.jpg)
<br>
<i>ws2</i>
<br>

</div>

> Первый файл содержит запрещающее правило на выход в начале списка правил, что приводит к тому, что первая машина не может пропинговать другую машину. Второй файл содержит разрешающее правило в начале списка правил, что позволяет второй машине пропинговать другую. Различие между стратегиями в том, что в утилите iptables правила выполняются сверху вниз.

### 4.2. Утилита nmap

#### Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен

<div align= "center">

![](./images/part4_2_1.jpg)
<br>
<i>ws2 `ping 192.168.100.10`</i>
<br>
<br>
![](./images/part4_2_2.jpg)
<br>
<i>ws1 `ping 172.24.116.8`</i>
<br>

</div>

Устанавливаем утилиту nmap и проверяем работу ws1, которая не пингуется.

> `sudo apt-get install nmap` > <br>

> `sudo nmap 192.168.100.10`

<div align= "center">

![](./images/part4_2_3.jpg)
<br>
<i>`sudo nmap 192.168.100.10`</i>

</div>

Как и предполагалось ws1 не може пинговаться ws2 из за настроек таблицы FILTER в цепи INPUT, в то время как ws1 все езе способна пинговать ws2.

## Part 5. Статическая маршрутизация сети

<div align= "center">

![](./images/part5_network.png)
<br>
<i>The scheme of network</i>

</div>

#### Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))

Создаем 5 машин и называем их соответсвенно схеме:

<div align= "center">

![](./images/part5_0_0.jpg)
<br>
<i>UTM</i>

</div>

### 5.1. Настройка адресов машин

#### Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.

Настраиваем статический ip в соответсвии со схемой для каждой машины:

<div align= "center">

![](./images/part5_1_1.jpg)
<br>
<i>ws11</i>
<br>
<br>
![](./images/part5_1_2.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part5_1_3.jpg)
<br>
<i>ws22</i>
<br>
<br>
![](./images/part5_1_4.jpg)
<br>
<i>r1</i>
<br>
<br>
![](./images/part5_1_5.jpg)
<br>
<i>r2</i>
<br>
<br>

</div>

#### Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

Перезапускаем сервисы сети с помощью команды:

> `sudo netplan apply`

Проверяем адресса сетевых интерфесов машины командой:

> `sudo ip -4 a` > `-4` - вывод только IPv4 адрессов

<div align= "center">

![](./images/part5_1_6.jpg)
<br>
<i>ws11</i>
<br>
<br>
![](./images/part5_1_7.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part5_1_8.jpg)
<br>
<i>ws22</i>
<br>
<br>
![](./images/part5_1_9.jpg)
<br>
<i>r1</i>
<br>
<br>
![](./images/part5_1_10.jpg)
<br>
<i>r2</i>
<br>
<br>

</div>

Все адресса верны. Теперь пропингуем ws22 с ws21:

<div align= "center">

![](./images/part5_1_11.jpg)
<br>
<i>ws21 `sudo ping 10.20.0.20`</i>

</div>

Также пропингуем r1 с ws11:

<div align= "center">

![](./images/part5_1_12.jpg)
<br>
<i>ws11 `ping 10.10.0.1`</i>

</div>

### 5.2. Включение переадресации IP-адресов.

#### Для включения переадресации IP, выполните команду на роутерах:

> `sysctl -w net.ipv4.ip_forward=1`
> При таком подходе переадресация не будет работать после перезагрузки системы.

Команда sudo sysctl -w net.ipv4.ip_forward=1 включает пересылку пакетов IP на уровне ядра. Это позволяет маршрутизатору пересылать пакеты между разными подсетями в локальной сети.

- `sysctl` используется для настройки параметров ядра операционной системы.

- `-w` указывает на то, что мы хотим изменить значение параметра.

- `net.ipv4.ip_forward` - это имя параметра, который мы хотим изменить. Он отвечает за пересылку пакетов IP на уровне ядра.

- `1` - это значение, которое мы устанавливаем для параметра, чтобы включить пересылку пакетов IP. Значение 0 отключает эту опцию.

<div align= "center">

![](./images/part5_2_1.jpg)
<br>
<i>r1</i>
<br>
<br>
![](./images/part5_2_2.jpg)
<br>
<i>r2</i>
<br>

</div>

#### Откройте файл /etc/sysctl.conf и добавьте в него следующую строку:

> `net.ipv4.ip_forward = 1`
> При использовании этого подхода, IP-переадресация включена на постоянной основе.

<div align= "center">

![](./images/part5_2_3.jpg)
<br>
<i>r1</i>
<br>
<br>
![](./images/part5_2_4.jpg)
<br>
<i>r2</i>
<br>

</div>

### 5.3. Установка маршрута по-умолчанию

#### Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций

Настраиваем в конфигурации yaml файла ip роутера

<div align= "center">

![](./images/part5_3_1.jpg)
<br>
<i>ws11</i>
<br>
<br>
![](./images/part5_3_2.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part5_3_3.jpg)
<br>
<i>ws22</i>
<br>

</div>

Применяем изменения в силу:

> `sudo netplan apply`

#### Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации

Чтобы проверить новый маршрут вызовем таблицу маршрутов командой:

> `ip r`

<div align= "center">

![](./images/part5_3_4.jpg)
<br>
<i>ws11</i>
<br>
<br>
![](./images/part5_3_5.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part5_3_6.jpg)
<br>
<i>ws22</i>
<br>

</div>

#### Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:

> `tcpdump -tn -i eth1`

Позволяет производить захват сетевого трафика на интерфейсе eth1 в текстовом формате без использования имён хостов и портов. Она предназначена для анализа сетевой активности и может использоваться для отслеживания соединений, поиска узких мест и проблем в сети.

- `-tn`: опция позволяет выводить адреса в числовом формате и пропускать DNS-преобразование имёнхостов;
- `-i` eth1: опция позволяет указать интерфейс, на котором будет производиться захват трафика. Вданном случае захват будет осуществляться на интерфейсе eth1.

Если пропинговать r2 с ws11 то ответ с него не вернется, так как на нем не настроена маршрутизация пакетов. Однако исользуя комадну `tcpdump -tn -i eth1` на r2 мы можем увидеть что все таки сигнал проходит.

Для этого запускаем эту команду на r2

<div align= "center">

![](./images/part5_3_7.jpg)
<br>
<i>r2 `tcpdump -tn -i eth1`</i>
<br>

</div>

И в этот момент начинаем пинговать с ws11 r2

<div align= "center">

![](./images/part5_3_8.jpg)
<br>
<i>ws11 `ping 10.100.0.12`</i>
<br>

</div>

По итогу на r2 мы увидим что сигнал от ws11 проходит, но не возвращается назад.

<div align= "center">

![](./images/part5_3_9.jpg)
<br>
<i>r2</i>
<br>

</div>

### 5.4. Добавление статических маршрутов

#### Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:

Чтобы роутеры знали, на какой роутер отправлять данные с полученным ip настроим статические маршрут. Для этого требуется внести изменения в yaml файл.

<div align= "center">

![](./images/part5_4_1.jpg)
<br>
<i>r2</i>
<br>
<br>
![](./images/part5_4_2.jpg)
<br>
<i>r1</i>
<br>

</div>

Осталось применить изменения командой:

> `sudo netplan apply`

#### Вызвать ip r и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:

<div align= "center">

![](./images/part5_4_3.jpg)
<br>
<i>r2</i>
<br>
<br>
![](./images/part5_4_4.jpg)
<br>
<i>r1</i>
<br>

</div>

#### Запустить команды на ws11:

ip r list 10.10.0.0/[маска сети] и ip r list 0.0.0.0/0

<div align= "center">

![](./images/part5_4_5.jpg)
<br>
<i>ws11</i>
<br>

</div>

Поскольку ws11 находится внутри сети 10.10.0.0/18, то для связи с ней она использует свой собвтенный ip. Однако для чтобы связаться с другими сетями, ws11 использует маршрут по умолчанию и отправляет данные на роутер, чтобы тот доставил их в нужную сеть.

### 5.5. Построение списка маршрутизаторов

Команда `traceroute` отправит серию пакетов с увеличивающимися значениями TTL (Time To Live) и отследит время их прохождения через промежуточные узлы маршрутизации. Это позволяет определить, через какие узлы проходит путь до указанного назначения и сколько времени занимает доставка пакетов до каждого из узлов.

#### Запустить на r1 команду дампа:

> `tcpdump -tnv -i eth0`

Команда `tcpdump -tnv -i eth0` запускает утилиту `tcpdump` для захвата сетевого трафика на интерфейсе eth0 в текстовом формате.

`-t` - отключает вывод временной метки

`-n` - отключает вывод имени хоста (или ip-адреса, если опция -n применяется и для анализа IP-адресов)

`-v` - увеличивает уровень детализации вывода

`-i` eth0 - задает интерфейс eth0, на котором будет происходить захват

Запускаем дамп на r1:

<div align= "center">

![](./images/part5_5_1.jpg)
<br>
<i>r1</i>
<br>

</div>

#### При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21

<div align= "center">

![](./images/part5_5_3.jpg)
<br>
<i>ws11</i>
<br>
<br>
![](./images/part5_5_2.jpg)
<br>
<i>r1</i>
<br>

</div>

Traceroute использует принцип увеличения значения поля TTL (Time To Live) в сетевых пакетах для определения маршрута до указанного назначения. Вот основной принцип работы команды traceroute:

- Команда traceroute отправляет серию пакетов с низким значением TTL (обычно 1) к указанномназначению (например, IP-адрес или доменное имя).

- Когда пакет с низким значением TTL попадает на маршрутизатор (или другой узел) по путизначение TTL уменьшается на 1. Если значение TTL достигает нуля, пакет считается истекшим маршрутизатор отправляет обратно сообщение "Time Exceeded" (время истекло) обратно отправителю.

- Команда traceroute записывает адрес каждого промежуточного узла, от которого полученсообщение "Time Exceeded", и время, затраченное на доставку пакета до этого узла.

- Для следующего пакета команда traceroute увеличивает значение TTL на 1 и отправляет его сноваЭто делается для определения следующего узла на маршруте.

- Процесс повторяется, пока пакеты не достигнут указанного назначения или не превысямаксимальное количество прыжков (указанное в команде traceroute).

- В итоге команда traceroute выводит список адресов промежуточных узлов и время задержки ping до каждого узла на пути до указанного назначения.

### Использование протокола ICMP при маршрутизации

`ICMP (Internet Control Message Protocol)` - это протокол, используемый для передачи сообщений об ошибках и управляющих сообщений в сетях IP. ICMP обычно используется для тестирования сети и диагностики соединений. Он работает на уровне интернета (IP) и использует специальные сообщения, называемые ICMP-сообщениями, для передачи информации между устройствами в сети.

#### Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:

> `sudo tcpdump -n -i eth0 icmp`

<div align= "center">

![](./images/part5_6_1.jpg)
<br>
<i>r1</i>
<br>

</div>

#### Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:

> `ping -c 1 10.30.0.111`

<div align= "center">

![](./images/part5_6_2.jpg)
<br>
<i>r1</i>
<br>

</div>

## Part 6. Динамическая настройка IP с помощью DHCP

`DHCP (Dynamic Host Configuration Protocol)` - это протокол сетевого уровня, который позволяет автоматически назначать IP-адреса и другую сетевую конфигурацию устройствам в сети. DHCP позволяет избежать необходимости вручную настраивать каждое устройство в сети и упрощает администрирование сети.

Для использования возможностей DHCP внутри нашей локальной сети, нам необходимо установится `DHCP-сервер` или `dhcpd`.

> `dhcpd` - это программа, которая представляет собой сервер DHCP, используемый для автоматической настройки сетевых параметров устройств, подключенных к сети.

Для его установки используем команду:

> `sudo apt-get install isc-dhcp-server`

`ISC-DHCP (Internet Systems Consortium Dynamic Host Configuration Protocol)` — это реализация DHCP-сервера, разработанная Internet Systems Consortium. DHCP (Dynamic Host Configuration Protocol) - это протокол, используемый для автоматической настройки сетевых настроек компьютеров и других устройств в сети, таких как IP-адреса, маски подсети, шлюзы по умолчанию, DNS-серверы и т.д. Он предоставляет инструменты для настройки и управления DHCP-сервером на Linux-системах.

Если мы посмотрим в /etc/dhcp/ то не найдем там нужный файл.

<div align= "center">

![](./images/part6_1_0.jpg)
<br>
<i>r2</i>
<br>

</div>

Установливаем на r2 dhcpd:

<div align= "center">

![](./images/part6_1_1.jpg)
<br>
<i>Проверяем еще раз /etc/dhcp и находим там нужный файл</i>
<br>

</div>

#### Для r2 настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP:

1. указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:

Входим в режим редактирования файла `/etc/dhcp/dhcpd.conf` и вносим изменения:

<div align= "center">

![](./images/part6_1_2.jpg)
<br>
<i>r2</i>
<br>

</div>

2. в файле resolv.conf прописать nameserver 8.8.8.8.

<div align= "center">

![](./images/part6_1_3.jpg)
<br>
<i>r2 `sudo vi /etc/resolf.conf`</i>
<br>

</div>

#### Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.

Перезагрузим DHCP комадной и проверяем его работу:

> `sudo systemctl restart isc-dhcp-server`

> `sudo systemctl status isc-dhcp-server`

<div align= "center">

![](./images/part6_1_4.jpg)
<br>
<i>r2 `sudo vi /etc/resolf.conf`</i>
<br>

</div>

На машинах ws21 и ws22 сделаем DHCP-протокол аткивным и принимаем новые настройски netplan:

<div align= "center">

![](./images/part6_1_5.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part6_1_6.jpg)
<br>
<i>ws22</i>

</div>

Для перезапуска операционной системы используем на обоих машинах команду:

> `sudo systemctl reboot`

<div align= "center">

![](./images/part6_1_7.jpg)
<br>
<i>ws21</i>
<br>
<br>
![](./images/part6_1_8.jpg)
<br>
<i>ws22</i>

</div>

Пропингуем ws22 с ws21 по выделенному ip:

> `ping 10.20.0.2`

<div align= "center">

![](./images/part6_1_9.jpg)
<br>
<i>ws21</i>
<br>

</div>

#### Указать MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true

Заходим в yaml файл и добавляем туда новый MAC-адрес и активируем DHCP-протокол:

<div align= "center">

![](./images/part6_2_0.jpg)
<br>
<i>ws11</i>
<br>

</div>

Выключаем машину и меняем настройки ее MAC-адрес:

<div align= "center">

![](./images/part6_2_1.jpg)
<br>
<i>ws11</i>
<br>

</div>

#### Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты

На r1 нужно также установить dhcpd и отредактировать его с жесткой привязкой к MAC-адресу хоста (ws11). Это значит что конкретный ip внутри одной локальной сети будет всегда принадлежать устройству с конкретны MAC-адресом.

<div align= "center">

![](./images/part6_2_2.jpg)
<br>
![](./images/part6_2_3.jpg)
<br>
![](./images/part6_2_4.jpg)
<br>
<i>r1</i>
<br>

</div>

Также изменям параматры на yaml файле ws11, чтобы ей было можно выдать динамичный ip и перезапустим ее командой `rebbot`:

<div align= "center">

![](./images/part6_2_5.jpg)
<br>
<i>ws11</i>
<br>

</div>

Пропингуем ws11 с ws22 по ее димнамичному адрессу:

<div align= "center">

![](./images/part6_2_6.jpg)
<br>
<i>ws22</i>
<br>

</div>

#### Запросить с ws21 обновление ip адреса

Чтобы запросить обновление ip адреса на для ws21 сперва используем команду для удаления старого адреса:

> `sudo dhclient -r`

<div align= "center">

![](./images/part6_2_7.jpg)
<br>
![](./images/part6_2_8.jpg)
<br>
<i>ws22</i>
<br>

</div>

Теперь используем команду для назначения нового адреса:

> `sudo dhclient -v`

<div align= "center">

![](./images/part6_2_9.jpg)
<br>
<i>ws22</i>
<br>

</div>

#### В отчёте описать, какими опциями DHCP сервера пользовались в данном пункте.

В данному пункте были использованы такие опции DHCP как:

- `option routers` указывает шлюз по умолчанию для клиентов DHCP.
- `option domain-name-servers` определяет DNS-серверы, которые будут использоваться клиентами для разрешения DNS-имен в IP-адреса.
- `option domain-name` задает имя домена по умолчанию, которое будет использоваться клиентами DHCP.

## Part 7. NAT

#### В файле /etc/apache2/ports.conf на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным

`Apache2` - это это свободный веб-сервер, который позволяет создавать и хостить веб-сайты и веб-приложения.

Для начала нам необходимо установить программу apache2 на наши виртуальные машины:

> `sudo apt-get install apache2`

`Listen 80` означает, что сервер будет слушать все доступные IP-адреса на порту 80. Таким образом, сервер будет слушать запросы на порту 80 как с локального хоста, так и с других устройств, если они будут иметь доступ к серверу.

`Listen 0.0.0.0:80` означает тоже самое, но явно указывает, что сервер должен слушать все доступные IP-адреса.

Изменяем этот параметр в файле `/etc/apache2/ports.conf`

<div align= "center">

![](./images/part7_0.jpg)
<br>
<i>ws22</i>
<br>
![](./images/part7_1.jpg)
<br>
<i>r1</i>

</div>

#### Запустить веб-сервер Apache командой service apache2 start на ws22 и r1

> `service apache2 start`

<div align= "center">

![](./images/part7_2.jpg)
<br>
<i>ws22</i>
<br>
![](./images/part7_3.jpg)
<br>
<i>r1</i>

</div>

#### Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

Создаем файл firewall.sh:

> `sudo vi /etc/firewall.sh`

Вносим туда слудующие команды:

1. удаление правил в таблице filter - iptables -F

2. удаление правил в таблице "NAT" - iptables -F -t nat

3. отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP

<div align= "center">

![](./images/part7_4.jpg)
<br>
<i>ws22&r1</i>
<br>

</div>

Даем права этому файлу и запускаем его:

> ` sudo chmod +x /etc/firewall.sh | bash /etc/firewall.sh`

<div align= "center">

![](./images/part7_5.jpg)
<br>
<i>r2</i>
<br>

</div>

#### Проверить соединение между ws22 и r1 командой ping

<i>При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1</i>

Так как мы запретили форвард пакетов на r2, то r1 не может пинговать ws22:

<div align= "center">

![](./images/part7_6.jpg)
<br>
<i>пинг не проходит с r1 на ws22</i>
<br>
![](./images/part7_6.jpg)
<br>
<i>также пинг не проходит и в обратную сторону с ws22 на r1</i>

</div>

#### Добавить в файл ещё одно правило:

4. разрешить маршрутизацию всех пакетов протокола ICMP

Чтобы разрешить маршрутизацию всех пакетов протокола ICMP с помощью iptables, необходимо выполнить следующую команду:

> `iptables -A FORWARD -p icmp -j ACCEPT`

<div align= "center">

![](./images/part7_8.jpg)
<br>
<i>r2</i>
<br>

</div>

Применяем новые правила и проверяем таблицу правил:

<div align= "center">

![](./images/part7_9.jpg)
<br>
<i>r2</i>
<br>

</div>

#### Проверить соединение между ws22 и r1 командой ping

<div align= "center">

![](./images/part7_10.jpg)
<br>
<i>теперь пинг проходить и с r1 на ws22</i>
<br>
![](./images/part7_11.jpg)
<br>
<i>и обратно</i>

</div>

#### Добавить в файл ещё два правила:

5. включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)

6. включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети

`SNAT (Source Network Address Translation) и DNAT (Destination Network Address Translation)` - это два типа трансляции IP-адресов, используемых для изменения адресов источника и назначения в IP-пакетах при прохождении через маршрутизатор.

`SNAT` используется для изменения IP-адреса источника, когда пакет покидает локальную сеть и направляется во внешнюю сеть. Это позволяет скрыть реальный IP-адрес отправителя и использовать общедоступный IP-адрес маршрутизатора в качестве источника пакета.

`DNAT` используется для изменения IP-адреса назначения, когда пакет приходит во входящий интерфейс маршрутизатора. Это позволяет перенаправить трафик на другой IP-адрес в локальной сети, скрыть реальный IP-адрес получателя или разрешить доступ к локальным ресурсам из внешней сети.

<div align= "center">

![](./images/part7_12.jpg)
<br>
<i>`/etc/firewall на r2`</i>
<br>

</div>

Принимаем новые правила:

> `sudo chmid +x /etc/firewall`

> `sudo bash /etc/firewall`

#### Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:

> `telnet [адрес] [порт]`

- Telnet - это протокол прикладного уровня, использующийся для удаленного управления устройствами через интернет или локальную сеть. С помощью Telnet можно подключаться к серверам, обычно по протоколу TCP, и взаимодействовать с ними, отправляя команды и получая ответы.

Подключаемся к серверу apache установленному на r1 с ws22:

> `telnet 10.100.0.11 80`

<div align= "center">

![](./images/part7_13.jpg)
<br>
<i>ws22</i>
<br>

</div>

#### Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080)

Для этого обратимся по ip, который мы перехватили с помощью tcpdump:

> `telnet 10.100.0.12 8080`

<div align= "center">

![](./images/part7_14.jpg)
<br>
<i>r1</i>
<br>

</div>

## Part 8. Дополнительно. Знакомство с SSH Tunnels

Запускаем фаерволы из предыдущих заданий:

<div align= "center">

![](./images/part8_0.jpg)
<br>
<i>r2</i>
<br>

</div>

#### Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку Listen 80 на Listen localhost:80)

Изменяем listen и запускаем сервер apache:

<div align= "center">

![](./images/part8_1.jpg)
<br>
<br>
![](./images/part8_11.jpg)
<br>
<br>
![](./images/part8_2.jpg)
<br>
<i>ws22</i>
<br>

</div>

#### Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21

`Local TCP forwarding` (также известен как локальное перенаправление портов) - это метод использования SSH для перенаправления трафика между клиентской машиной и сервером SSH. Этот метод позволяет клиентской машине использовать SSH-соединение как "прокси-сервер" для обращения к удаленным ресурсам.`

В нашем случае, мы можем использовать Local TCP forwarding для перенаправления трафика с порта 8080 на ws21 на порт 80 на ws22. Для этого нужно выполнить следующую команду на ws21:

> `ssh -L 8080:ws22:80 ullertyr@10.20.0.20`

<div align= "center">

![](./images/part8_3.jpg)
<br>
<i>ws21</i>
<br>

</div>

Чтобы проверить подключение воспользуемся командой на ws22:

> `ps aux | grep sshd`

<div align= "center">

![](./images/part8_4.jpg)
<br>
<i>ws22</i>
<br>

</div>

Также проверим работу веб сервера на ws21:

> `telnet 127.0.0.1 8080`

<div align= "center">

![](./images/part8_5.jpg)
<br>
<i>ws21</i>
<br>

</div>

#### Воспользоваться Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11

Установить прямое соединение с ws11 не получится, поскольку на r2 стоит фаервол, который не пропустит это соединение. В данном случае прокладовать соединение необходимо с ws11, сначала до r2 и только потом на ws22. Это возможно потому что, фаервол пропускает установленные соединения.

Чтобы это сделать нужно будет воспользоваться командой `ssh -R`, которая позволяет соедениться со сторонним хостом.

Начнем с соединения ws11 с r2:

<div align= "center">

![](./images/part8_6.jpg)
<br>
<i>ws11</i>
<br>

</div>

Затем соединяемся с ws22:

<div align= "center">

![](./images/part8_7.jpg)
<br>
<i>ws11</i>
<br>

</div>

Теперь у нас есть проложенное соединение от ws11 до ws22, что означает, что можно соединяться с ws11 на прямую с помощью команды:

> `sudo ssh -R 8080:localhost:80 ullertyr@10.10.0.10`

<div align= "center">

![](./images/part8_9.jpg)
<br>
<i>ws11</i>
<br>

</div>

Для проверки наличия подключения используем команду `telnet 127.0.0.1 8080`

<div align= "center">

![](./images/part8_10.jpg)
<br>
<i>ws11</i>
<br>

</div>
